	diff -ruN NuttX/apps/nshlib/nsh_parse.c NuttX/apps/nshlib/nsh_parse.c
--- NuttX/apps/nshlib/nsh_parse.c	2016-02-02 15:13:19.241834143 +1100
+++ NuttX/apps/nshlib/nsh_parse.c	2016-02-04 15:50:46.851397765 +1100
@@ -156,9 +156,9 @@
 #endif
 
 static FAR char *nsh_argexpand(FAR struct nsh_vtbl_s *vtbl, FAR char *cmdline,
-               FAR char **allocation);
+               FAR char **allocation, int* isenvvar);
 static FAR char *nsh_argument(FAR struct nsh_vtbl_s *vtbl, char **saveptr,
-               FAR NSH_MEMLIST_TYPE *memlist);
+               FAR NSH_MEMLIST_TYPE *memlist, int* isenvvar);
 
 #ifndef CONFIG_NSH_DISABLESCRIPT
 #ifndef CONFIG_NSH_DISABLE_LOOPS
@@ -1001,7 +1001,7 @@
 
 #if defined(CONFIG_NSH_ARGCAT) && defined(HAVE_MEMLIST)
 static FAR char *nsh_argexpand(FAR struct nsh_vtbl_s *vtbl, FAR char *cmdline,
-                               FAR char **allocation)
+                               FAR char **allocation, int* isenvvar)
 {
   FAR char *working = cmdline;
   FAR char *argument = NULL;
@@ -1120,8 +1120,8 @@
           *allocation = argument;
 
           /* Find the end of the environment variable reference.  If the
-           * dollar sign ('$') is followed by a right bracket ('{') then the
-           * variable name is terminated with the left bracket character
+           * dollar sign ('$') is followed by a left bracket ('{') then the
+           * variable name is terminated with the right bracket character
            * ('}').  Otherwise, the variable name goes to the end of the
            * argument.
            */
@@ -1159,6 +1159,20 @@
            * nsh_envexpand will return the NULL string.
            */
 
+          if (isenvvar)
+            {
+              *isenvvar = 1;
+            }
+
+          /* Look for extra characters appended to the environment variable via a 
+           * period character. If found, terminate the variable before attempting expansion.
+           */
+          FAR char *p = strchr(ptr, '.');
+          if (p)
+            {
+              *p = '\0';
+            }
+
           envstr = nsh_envexpand(vtbl, ptr);
 
           /* Concatenate the result of the operation with the accumulated
@@ -1167,6 +1181,14 @@
            */
 
           argument    = nsh_strcat(vtbl, argument, envstr);
+          /* If we found addition characters appended to the environment variable as 
+           * above, then put them back on the expanded argument string.
+           */
+          if (p)
+            {
+              *p = '.';
+              argument    = nsh_strcat(vtbl, argument, p);
+            }
           *allocation = argument;
         }
       else
@@ -1179,7 +1201,7 @@
 
 #else
 static FAR char *nsh_argexpand(FAR struct nsh_vtbl_s *vtbl, FAR char *cmdline,
-                               FAR char **allocation)
+                               FAR char **allocation, int* isenvvar)
 {
   FAR char *argument = (FAR char *)g_nullstring;
 
@@ -1215,6 +1237,10 @@
 
   if (*cmdline == '$')
     {
+      if (isenvvar)
+        {
+          *isenvvar = 1;
+        }
       argument = nsh_envexpand(vtbl, cmdline + 1);
     }
   else
@@ -1237,7 +1263,7 @@
  ****************************************************************************/
 
 static FAR char *nsh_argument(FAR struct nsh_vtbl_s *vtbl, FAR char **saveptr,
-                              FAR NSH_MEMLIST_TYPE *memlist)
+                              FAR NSH_MEMLIST_TYPE *memlist, int* isenvvar)
 {
   FAR char *pbegin     = *saveptr;
   FAR char *pend       = NULL;
@@ -1309,6 +1335,13 @@
 
           pbegin++;
           term = "\"";
+
+          /* If this is an environment variable in double quotes, we don't want it split into
+           * multiple argument should CONFIG_NSH_ENABLEPX4PARSING be defined
+           * So just invalidate the flag pointer which would otherwise communictate such 
+           * back up the call tree.
+           */
+          isenvvar = NULL;
         }
       else
         {
@@ -1368,11 +1401,11 @@
 
       /* Perform expansions as necessary for the argument */
 
-      argument = nsh_argexpand(vtbl, pbegin, &allocation);
+      argument = nsh_argexpand(vtbl, pbegin, &allocation, isenvvar);
     }
 
   /* If any memory was allocated for this argument, make sure that it is
-   * added to the list of memory to be freed at the end of commend
+   * added to the list of memory to be freed at the end of command
    * processing.
    */
 
@@ -1489,7 +1522,7 @@
 
           /* Get the cmd following the "while" or "until" */
 
-          *ppcmd = nsh_argument(vtbl, saveptr, memlist);
+          *ppcmd = nsh_argument(vtbl, saveptr, memlist, 0);
           if (!*ppcmd)
             {
               nsh_output(vtbl, g_fmtarginvalid, "if");
@@ -1546,7 +1579,7 @@
         {
           /* Get the cmd following the "do" -- there may or may not be one */
 
-          *ppcmd = nsh_argument(vtbl, saveptr, memlist);
+          *ppcmd = nsh_argument(vtbl, saveptr, memlist, 0);
 
           /* Verify that "do" is valid in this context */
 
@@ -1566,7 +1599,7 @@
         {
           /* Get the cmd following the "done" -- there should be one */
 
-          *ppcmd = nsh_argument(vtbl, saveptr, memlist);
+          *ppcmd = nsh_argument(vtbl, saveptr, memlist, 0);
           if (*ppcmd)
             {
               nsh_output(vtbl, g_fmtarginvalid, "done");
@@ -1671,7 +1704,7 @@
         {
           /* Get the cmd following the if */
 
-          *ppcmd = nsh_argument(vtbl, saveptr, memlist);
+          *ppcmd = nsh_argument(vtbl, saveptr, memlist, 0);
           if (!*ppcmd)
             {
               nsh_output(vtbl, g_fmtarginvalid, "if");
@@ -1709,7 +1742,7 @@
         {
           /* Get the cmd following the "then" -- there may or may not be one */
 
-          *ppcmd = nsh_argument(vtbl, saveptr, memlist);
+          *ppcmd = nsh_argument(vtbl, saveptr, memlist, 0);
 
           /* Verify that "then" is valid in this context */
 
@@ -1728,7 +1761,7 @@
         {
           /* Get the cmd following the "else" -- there may or may not be one */
 
-          *ppcmd = nsh_argument(vtbl, saveptr, memlist);
+          *ppcmd = nsh_argument(vtbl, saveptr, memlist, 0);
 
           /* Verify that "else" is valid in this context */
 
@@ -1747,7 +1780,7 @@
         {
           /* Get the cmd following the fi -- there should be one */
 
-          *ppcmd = nsh_argument(vtbl, saveptr, memlist);
+          *ppcmd = nsh_argument(vtbl, saveptr, memlist, 0);
           if (*ppcmd)
             {
               nsh_output(vtbl, g_fmtarginvalid, "fi");
@@ -1819,10 +1852,10 @@
 
           /* Get the cmd (or -d option of nice command) */
 
-          cmd = nsh_argument(vtbl, saveptr, memlist);
+          cmd = nsh_argument(vtbl, saveptr, memlist, 0);
           if (cmd && strcmp(cmd, "-d") == 0)
             {
-              FAR char *val = nsh_argument(vtbl, saveptr, memlist);
+              FAR char *val = nsh_argument(vtbl, saveptr, memlist, 0);
               if (val)
                 {
                   char *endptr;
@@ -1833,7 +1866,7 @@
                       nsh_output(vtbl, g_fmtarginvalid, "nice");
                       return ERROR;
                     }
-                  cmd = nsh_argument(vtbl, saveptr, memlist);
+                  cmd = nsh_argument(vtbl, saveptr, memlist, 0);
                 }
             }
 
@@ -1901,7 +1934,7 @@
   /* Parse out the command at the beginning of the line */
 
   saveptr = cmdline;
-  cmd = nsh_argument(vtbl, &saveptr, &memlist);
+  cmd = nsh_argument(vtbl, &saveptr, &memlist, 0);
 
   /* Check if any command was provided -OR- if command processing is
    * currently disabled.
@@ -1935,7 +1968,7 @@
   argv[0] = cmd;
   for (argc = 1; argc < MAX_ARGV_ENTRIES-1; argc++)
     {
-      argv[argc] = nsh_argument(vtbl, &saveptr, &memlist);
+      argv[argc] = nsh_argument(vtbl, &saveptr, &memlist, 0);
       if (!argv[argc])
         {
           break;
@@ -2002,7 +2035,7 @@
   /* Parse out the command at the beginning of the line */
 
   saveptr = cmdline;
-  cmd = nsh_argument(vtbl, &saveptr, &memlist);
+  cmd = nsh_argument(vtbl, &saveptr, &memlist, 0);
 
 #ifndef CONFIG_NSH_DISABLESCRIPT
 #ifndef CONFIG_NSH_DISABLE_LOOPS
@@ -2070,15 +2103,54 @@
    */
 
   argv[0] = cmd;
+
+#define CONFIG_NSH_ENABLEPX4PARSING
+
   for (argc = 1; argc < MAX_ARGV_ENTRIES-1; argc++)
     {
-      argv[argc] = nsh_argument(vtbl, &saveptr, &memlist);
+      int isenvvar = 0; /* flag for if an enviroment variable gets expanded */
+      argv[argc] = nsh_argument(vtbl, &saveptr, &memlist, &isenvvar);
       if (!argv[argc])
         {
           break;
         }
+
+#ifdef CONFIG_NSH_ENABLEPX4PARSING
+      if (isenvvar)
+        {
+          while (argc < MAX_ARGV_ENTRIES-1) /* TODO: check this bounds check is correct */
+            {
+              FAR char *pbegin = argv[argc];
+
+              /* Find the end of the current token */
+              for (; *pbegin && !strchr(g_token_separator, *pbegin); pbegin++);
+
+              /* If end of string, we've processed the last token and we're done */
+              if ('\0' == *pbegin)
+                {
+                  break;
+                }
+
+              /* Terminate the token to complete the argv variable */
+              *pbegin = '\0';
+
+              /* We've inserted an extra parameter, so bump the count */
+              argc++;
+
+              /* Move to the next character in the string of tokens */
+              pbegin++;
+
+              /* Throw away any extra separator chars between tokens */
+              for (; *pbegin && strchr(g_token_separator, *pbegin) != NULL; pbegin++);
+
+              /* Prepare to loop again on the next argument token */
+              argv[argc] = pbegin;
+            }
+        }
+#endif /* CONFIG_NSH_ENABLEPX4PARSING */
     }
 
+  /* Last argument vector must be empty */
   argv[argc] = NULL;
 
   /* Check if the command should run in background */
